### Comment la faille a été trouvée:

1. Depuis la page d'accueil on nous propose d'ajouter une image (cf. img 1).
Cela nous donne la possibilitée d'envoyer du contenu au serveur (cf. img 2).
Cela pourrait représenter un danger si il est mal configuré => comme envoyé du code
malveillantque le serveur ne bloqueraa pas.

2. Il faut donc qu'il vérifie que on envoie de vraies images, et empêcher l'execution de code à travers
ce moyen.

### Comment la faille a été exploitée:

3. Essayons d'abord d'envoyer une simple image (.png): Le serveur refuse le format (.png). (cf. img 3).
On essaye ensuite avec un (.jpg) (cf. img 4): ca fonctionne !

4. Via une requête http il est possible d'outrepasser l'upload simple d'un fichier côté frontend.

5. Pour cela on va utiliser curl déjà disponnible sous windows. On va d'abord faire le test avec une img simple type .jpg via cette commande:
curl -X POST `
  -H "Content-Type: multipart/form-data" `
  -F "uploaded=@test.jpg;type=image/jpeg" `
  -F "Upload=Upload" `
  http://127.0.0.1:8080/?page=upload

  On a une reponse côté serveur : *"<pre>/tmp/test.jpg succesfully uploaded.</pre>"*

6. Maintenant on va tenter la même chose mais avec un fichier déguisé => on injecte du code php que l'on fait passer pour une image.

Je crée un fichier php "test.php" que je renomme ensuite "test.php.jpg"

Et je l'envoie sous requête http via curl:
curl.exe -X POST -H "Content-Type: multipart/form-data" -F "uploaded=@test.php.jpg;type=image/jpeg" -F "Upload=Upload" http://127.0.0.1:8080/?page=upload

Le fichier est uploader avec succès: *"<pre>/tmp/test.php.jpg succesfully uploaded.</pre>"*

On refait enfin la même chose sauf que la on envoie un fichier .php tout court, en le faisant passer pour un jpeg:

curl.exe -X POST -H "Content-Type: multipart/form-data" -F "uploaded=@test.php;type=image/jpeg" -F "Upload=Upload" http://127.0.0.1:8080/?page=upload

7. Et on obtient le flag dans la reponse à notre requête ! (cf. img flag_dans_reponse)

### Comment la faille peut être corrigée:

- Ne jamais se fier uniquement à l’extension du fichier (ex: .jpg) pour valider son type.

- Ne jamais se fier au Content-Type fourni par l’utilisateur (ex: image/jpeg).

- Utiliser getimagesize() ou exif_imagetype() pour valider une vraie image.

- Désactiver l'exécution de scripts dans le dossier d'upload (ex: .htaccess → php_flag engine off).

- Refuser les extensions multiples (.php.jpg, .jpg.php, .php.jpg.jpg...).
